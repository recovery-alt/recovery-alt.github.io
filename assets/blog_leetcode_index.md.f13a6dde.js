import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.a4f2a176.js";const F=JSON.parse('{"title":"记录力扣日常","description":"记录自己的力扣之旅","frontmatter":{"title":"记录力扣日常","date":"2021-04-09T00:00:00.000Z","description":"记录自己的力扣之旅","readMins":8,"tags":["LeetCode"]},"headers":[],"relativePath":"blog/leetcode/index.md","filePath":"blog/leetcode/index.md"}'),p={name:"blog/leetcode/index.md"},o=l(`<h2 id="easy" tabindex="-1">easy <a class="header-anchor" href="#easy" aria-label="Permalink to &quot;easy&quot;">​</a></h2><h3 id="罗马文字解析" tabindex="-1">罗马文字解析 <a class="header-anchor" href="#罗马文字解析" aria-label="Permalink to &quot;罗马文字解析&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noreferrer">地址</a></p><blockquote><p>当前数字小于后一个的值时，后一个值减去前一个值，i++</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (val </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> map[s[i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> map[s[i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]] </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> val;</span></span>
<span class="line"><span style="color:#E1E4E8;">  i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (val </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> map[s[i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]]) {</span></span>
<span class="line"><span style="color:#24292E;">  val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> map[s[i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]] </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> val;</span></span>
<span class="line"><span style="color:#24292E;">  i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="最长公共前缀" tabindex="-1">最长公共前缀 <a class="header-anchor" href="#最长公共前缀" aria-label="Permalink to &quot;最长公共前缀&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/" target="_blank" rel="noreferrer">地址</a></p><ul><li>先遍历一次拿长度最短的</li><li>再遍历比较遇到值不对的直接跳出，并截取公共串</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (demo[j] </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> str[j]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  demo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> demo.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, j);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (demo[j] </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> str[j]) {</span></span>
<span class="line"><span style="color:#24292E;">  demo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> demo.</span><span style="color:#6F42C1;">slice</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, j);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>更好的思路</p><ul><li>取第一个为参照</li><li>依次去对比所有项中对应的字符</li><li>遇到不同退出循环，记录第一个参照此时的索引</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> len) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nowChar </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> strs[j][i]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    flag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (flag) </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> len) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nowChar </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> strs[j][i]) {</span></span>
<span class="line"><span style="color:#24292E;">    flag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (flag) </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span></code></pre></div><h3 id="有效的括号" tabindex="-1">有效的括号 <a class="header-anchor" href="#有效的括号" aria-label="Permalink to &quot;有效的括号&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noreferrer">地址</a></p><blockquote><p>优化思路，这种找对应关系的题目，可以通过取余来判断</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (len </span><span style="color:#F97583;">%</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (len </span><span style="color:#D73A49;">%</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span></code></pre></div><h3 id="合并两个有序链表" tabindex="-1">合并两个有序链表 <a class="header-anchor" href="#合并两个有序链表" aria-label="Permalink to &quot;合并两个有序链表&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noreferrer">地址</a></p><p>思路一：</p><ul><li>用一个结果链表装载结果</li><li>每次移动 l1/l2 中的较小值的那个指针</li><li>将结果指针指向较小值的那个节点</li><li>后移较小值的指针和结果链表的指针</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mergeTwoLists</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">l1</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">l2</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">prevHead</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ListNode</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> prevNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> prevHead;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (l1 </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> l2) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (l1.val </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> l2.val) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      prevNode.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> l1;</span></span>
<span class="line"><span style="color:#E1E4E8;">      l1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> l1.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      prevNode.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> l2;</span></span>
<span class="line"><span style="color:#E1E4E8;">      l2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> l2.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    prevNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> prevNode.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  prevNode.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> l1 </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> l2;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> prevHead.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mergeTwoLists</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">l1</span><span style="color:#24292E;">, </span><span style="color:#E36209;">l2</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">prevHead</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ListNode</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> prevNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> prevHead;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (l1 </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> l2) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (l1.val </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> l2.val) {</span></span>
<span class="line"><span style="color:#24292E;">      prevNode.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> l1;</span></span>
<span class="line"><span style="color:#24292E;">      l1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> l1.next;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      prevNode.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> l2;</span></span>
<span class="line"><span style="color:#24292E;">      l2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> l2.next;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    prevNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> prevNode.next;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  prevNode.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> l1 </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> l2;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> prevHead.next;</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><p>思路二：</p><ul><li>将结果集由 l1/l2 输出</li><li>通过移动 l1/l2 的指针不断递归</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mergeTwoLists</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">l1</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">l2</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">l1) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> l2;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">l2) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> l1;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (l1.val </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> l2.val) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    l1.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mergeTwoLists</span><span style="color:#E1E4E8;">(l1.next, l2);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> l1;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    l2.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mergeTwoLists</span><span style="color:#E1E4E8;">(l1, l2.next);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> l2;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mergeTwoLists</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">l1</span><span style="color:#24292E;">, </span><span style="color:#E36209;">l2</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">l1) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> l2;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">l2) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> l1;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (l1.val </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> l2.val) {</span></span>
<span class="line"><span style="color:#24292E;">    l1.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mergeTwoLists</span><span style="color:#24292E;">(l1.next, l2);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> l1;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    l2.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mergeTwoLists</span><span style="color:#24292E;">(l1, l2.next);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> l2;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><h3 id="删除有序数组中的重复项" tabindex="-1">删除有序数组中的重复项 <a class="header-anchor" href="#删除有序数组中的重复项" aria-label="Permalink to &quot;删除有序数组中的重复项&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noreferrer">地址</a></p><blockquote><ol><li>不能使用额外空间</li><li>不需要处理之后的元素</li></ol></blockquote><ul><li>用两个指针，<code>i=1</code>、<code>j=0</code>，\b\b\b<code>i</code>是遍历的指针，<code>j</code>是输出集的指针</li><li><code>nums[i] !== nums[i - 1]</code>，<code>j++</code>，并且<code>nums[j] = nums[i]</code></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nums[i] </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> nums[i </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  nums[j] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nums[i] </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> nums[i </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) {</span></span>
<span class="line"><span style="color:#24292E;">  j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  nums[j] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[i];</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span></code></pre></div><h3 id="实现-strstr" tabindex="-1">实现 strStr() <a class="header-anchor" href="#实现-strstr" aria-label="Permalink to &quot;实现 strStr()&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/implement-strstr/solution/" target="_blank" rel="noreferrer">地址</a></p><ul><li>比较长度，仅在前者长度大于后者进行遍历</li><li>遍历长度为<code>len1 - len2 + 1</code></li><li>不相等直接退出内部循环</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark has-diff vp-code-dark"><code><span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> diff </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> equal </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> len2; j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (haystack[i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> j] </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> needle[j]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        equal </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (equal) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> i;</span></span></code></pre><pre class="shiki github-light has-diff vp-code-light"><code><span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> diff </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> equal </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> len2; j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (haystack[i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> j] </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> needle[j]) {</span></span>
<span class="line"><span style="color:#24292E;">        equal </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (equal) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> i;</span></span></code></pre></div><h3 id="外观数列" tabindex="-1">外观数列 <a class="header-anchor" href="#外观数列" aria-label="Permalink to &quot;外观数列&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noreferrer">地址</a></p><p>思路一：正则表达式</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">start </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> start.</span><span style="color:#B392F0;">replace</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">/</span><span style="color:#DBEDFF;">(</span><span style="color:#79B8FF;">\\d</span><span style="color:#DBEDFF;">)</span><span style="color:#F97583;">\\1*</span><span style="color:#9ECBFF;">/</span><span style="color:#F97583;">g</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">matcher</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">\`\${</span><span style="color:#E1E4E8;">matcher</span><span style="color:#9ECBFF;">.</span><span style="color:#79B8FF;">length</span><span style="color:#9ECBFF;">}\${</span><span style="color:#E1E4E8;">matcher</span><span style="color:#9ECBFF;">[</span><span style="color:#79B8FF;">0</span><span style="color:#9ECBFF;">]</span><span style="color:#9ECBFF;">}\`</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">start </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> start.</span><span style="color:#6F42C1;">replace</span><span style="color:#24292E;">(</span><span style="color:#032F62;">/(</span><span style="color:#005CC5;">\\d</span><span style="color:#032F62;">)</span><span style="color:#D73A49;">\\1*</span><span style="color:#032F62;">/</span><span style="color:#D73A49;">g</span><span style="color:#24292E;">, </span><span style="color:#E36209;">matcher</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">\`\${</span><span style="color:#24292E;">matcher</span><span style="color:#032F62;">.</span><span style="color:#005CC5;">length</span><span style="color:#032F62;">}\${</span><span style="color:#24292E;">matcher</span><span style="color:#032F62;">[</span><span style="color:#005CC5;">0</span><span style="color:#032F62;">]</span><span style="color:#032F62;">}\`</span><span style="color:#24292E;">);</span></span></code></pre></div><h3 id="最大子序和" tabindex="-1">最大子序和 <a class="header-anchor" href="#最大子序和" aria-label="Permalink to &quot;最大子序和&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noreferrer">地址</a></p><p>思路一：动态规划</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 转移方程</span></span>
<span class="line"><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">(i) </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">(i </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> nums[i], nums[i]);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 转移方程</span></span>
<span class="line"><span style="color:#6F42C1;">f</span><span style="color:#24292E;">(i) </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">(i </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> nums[i], nums[i]);</span></span></code></pre></div><ol><li>前 i 项的最大值 = 前 i-1 项最大值 + 第 i 项 和 第 i 项的最大值</li><li>保留每次计算的前 i 项的和和前 i 项的最大值</li><li>取其中的最大值</li></ol><h3 id="最后一个单词的长度" tabindex="-1">最后一个单词的长度 <a class="header-anchor" href="#最后一个单词的长度" aria-label="Permalink to &quot;最后一个单词的长度&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noreferrer">地址</a></p><p>思路从右往左遍历，先去除所有空格，再计算长度，再次遇到空格或者 i=0 输出结果</p><h3 id="x-的平方根" tabindex="-1">x 的平方根 <a class="header-anchor" href="#x-的平方根" aria-label="Permalink to &quot;x 的平方根&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noreferrer">地址</a></p><p>二分查找,对比<code>mid * mid</code>和<code>x</code>的大小，<code>mid * mid &lt; x</code></p><h3 id="合并两个有序数组" tabindex="-1">合并两个有序数组 <a class="header-anchor" href="#合并两个有序数组" aria-label="Permalink to &quot;合并两个有序数组&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noreferrer">地址</a></p><p>双指针法 从前往后遍历需要额外的空间 时间复杂度：O(m+n) 空间复杂度：O(m+n)</p><p>优化思路 从后往前遍历，因为后面都是 0，不会出现覆盖的问题 时间复杂度：O(m+n) 空间复杂度：O(1)</p><h3 id="只出现一次的数字" tabindex="-1">只出现一次的数字 <a class="header-anchor" href="#只出现一次的数字" aria-label="Permalink to &quot;只出现一次的数字&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noreferrer">地址</a></p><p>使用异或运算符<code>^</code>，具备以下特点</p><ul><li><code>a ^ 0 === a</code></li><li><code>a ^ a === 0</code></li><li><code>a ^ b ^ a === b</code></li></ul><h3 id="相交链表" tabindex="-1">相交链表 <a class="header-anchor" href="#相交链表" aria-label="Permalink to &quot;相交链表&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noreferrer">地址</a></p><p>双指针法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">p1: headA =&gt; headA End =&gt; headB =&gt; node</span></span>
<span class="line"><span style="color:#e1e4e8;">p2: headB =&gt; headB End =&gt; headA =&gt; node</span></span>
<span class="line"><span style="color:#e1e4e8;">如果相交的话，则满足：</span></span>
<span class="line"><span style="color:#e1e4e8;">a + (b - c) = b + (a - c)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">p1: headA =&gt; headA End =&gt; headB =&gt; node</span></span>
<span class="line"><span style="color:#24292e;">p2: headB =&gt; headB End =&gt; headA =&gt; node</span></span>
<span class="line"><span style="color:#24292e;">如果相交的话，则满足：</span></span>
<span class="line"><span style="color:#24292e;">a + (b - c) = b + (a - c)</span></span></code></pre></div><h3 id="多数元素" tabindex="-1">多数元素 <a class="header-anchor" href="#多数元素" aria-label="Permalink to &quot;多数元素&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noreferrer">地址</a></p><ul><li><p>思路一：hash table 时间复杂度：O(n) 空间复杂度：O(n)</p></li><li><p>思路二：打分法 遍历，然后给每一个元素打分，等于 candidate 记为 1，不等于记为-1，<code>count===0</code>表示需要变更<code>candidate</code> 核心思想就是多数是大于<code>n / 2</code>，所以通过消除法，最后剩余的肯定是最多的数</p></li></ul><h3 id="阶乘后的零" tabindex="-1">阶乘后的零 <a class="header-anchor" href="#阶乘后的零" aria-label="Permalink to &quot;阶乘后的零&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noreferrer">地址</a></p><p>规律就是</p><ul><li>每隔 5 个数出现一次 0，所以总数应该是 n / 5</li><li>但是每隔 25 个数又会额外多处一个 1 一个 0</li><li>每隔 625 个数又会额外多处一个 0</li><li>以此类推</li><li>总数 = n / 5 + n / 25 + n / 625 +++</li></ul><h3 id="颠倒二进制位" tabindex="-1">颠倒二进制位 <a class="header-anchor" href="#颠倒二进制位" aria-label="Permalink to &quot;颠倒二进制位&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noreferrer">地址</a></p><p>位运算符笔记</p><ul><li>&gt;&gt; 右移运算符，正数高位补 0，负数高位补 1 <code>111</code> =&gt; <code>11</code> <code>-111</code> =&gt; <code>11111111111111111111111111111100</code></li><li>&lt;&lt; 左移运算符，低位补 0 <code>111</code> =&gt; <code>1110</code></li><li>&gt;&gt;&gt; 无符号右移，高位补 0 <code>-111</code> =&gt; <code>11111111111111111111111111111000</code> =&gt; <code>01111111111111111111111111111100</code></li></ul><ol><li>JavaScript 中数字存储格式是 64 位浮点数</li><li>JavaScript 中进行位运算的数字格式是 32 位二进制数</li><li>负数的二进制写法是正数的二进制补码+1</li><li>这种长位数作运算的时候会用 16 进制来表示，即四位变成一位，用 0x 作开头</li><li>toString(2)可以将十进制转换成二进制，带正负号。。</li></ol><p>无符号右移 0 作用 <a href="https://www.jianshu.com/p/588eb74b5a03" target="_blank" rel="noreferrer">地址</a></p><h3 id="快乐数" tabindex="-1">快乐数 <a class="header-anchor" href="#快乐数" aria-label="Permalink to &quot;快乐数&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/happy-number/description/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：哈希表，缓存所有值</li><li>思路二：可以理解为一个循环指针</li></ul><h3 id="计算质数" tabindex="-1">计算质数 <a class="header-anchor" href="#计算质数" aria-label="Permalink to &quot;计算质数&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：暴力法</li><li>思路二：依此遍历，如果 i 是质数，则 i 的 x 倍是合数，缓存结果减少计算</li></ul><h3 id="反转链表" tabindex="-1">反转链表 <a class="header-anchor" href="#反转链表" aria-label="Permalink to &quot;反转链表&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：迭代</li><li>思路二：递归，归的过程需要反转两个链表<code>head.next.next = head; head.next = null;</code></li></ul><h3 id="汇总区间" tabindex="-1">汇总区间 <a class="header-anchor" href="#汇总区间" aria-label="Permalink to &quot;汇总区间&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/summary-ranges/" target="_blank" rel="noreferrer">地址</a></p><p>读清楚题目，要求是连续就收起来，不连续就单独放 <code>0 1 2 4 5 7</code><code>0 1 2</code>连续 =&gt; <code>0-&gt;2</code><code>4 5</code> 连续 =&gt; <code>4-&gt;5</code><code>7</code> =&gt; <code>7</code></p><h3 id="_2-的幂" tabindex="-1">2 的幂 <a class="header-anchor" href="#_2-的幂" aria-label="Permalink to &quot;2 的幂&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noreferrer">地址</a></p><p>2 的幂满足二进制表示的时候只有一个 1，且在最高位 所以可以判断<code>n &amp; (n - 1)</code>是否等于 0 来求解</p><h3 id="回文链表" tabindex="-1">回文链表 <a class="header-anchor" href="#回文链表" aria-label="Permalink to &quot;回文链表&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：转为数组，然后循环判断是否回文</li><li>思路二：快慢指针，找到中点并且反转前半部分 =&gt; 对比反转链表和剩余链表的值</li></ul><h3 id="二叉搜索树的最近公共祖先" tabindex="-1">二叉搜索树的最近公共祖先 <a class="header-anchor" href="#二叉搜索树的最近公共祖先" aria-label="Permalink to &quot;二叉搜索树的最近公共祖先&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：先找到 p 和 q 节点的路径，再对比找到最后一个相等的节点就是高度最低的节点</li><li>思路二：如果 p 和 q 都当前节点小，<code>node = node.left</code>，如果都比当前节点大<code>node = node.right</code>，找到介于两者之间的值就是结果</li><li>思路三：递归实现思路二</li></ul><h3 id="各数相加" tabindex="-1">各数相加 <a class="header-anchor" href="#各数相加" aria-label="Permalink to &quot;各数相加&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/add-digits/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：循环+递归</li><li>思路二：可以理解为除以 9 的余数</li></ul><h3 id="丑数" tabindex="-1">丑数 <a class="header-anchor" href="#丑数" aria-label="Permalink to &quot;丑数&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noreferrer">地址</a></p><ol><li>丑数大于 0</li><li>丑数只能被 2、3、5 整除</li><li>1 被视为丑数</li></ol><h3 id="丢失的数字" tabindex="-1">丢失的数字 <a class="header-anchor" href="#丢失的数字" aria-label="Permalink to &quot;丢失的数字&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：排序，然后对比下标和值</li><li>思路二：异或运算</li><li>思路三：求<code>0-n</code>的和，减去所有值的和就是结果</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">0 ^ 0 ^ 1 ^ 1 ^ 2 ^ 3 ^ 3 =&gt; 2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">0 ^ 0 ^ 1 ^ 1 ^ 2 ^ 3 ^ 3 =&gt; 2</span></span></code></pre></div><h3 id="第一个错误的版本" tabindex="-1">第一个错误的版本 <a class="header-anchor" href="#第一个错误的版本" aria-label="Permalink to &quot;第一个错误的版本&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noreferrer">地址</a></p><p>二分求中位数</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">mid</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">floor</span><span style="color:#E1E4E8;">(start </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> (end </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> start) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">mid</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">floor</span><span style="color:#24292E;">(start </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> (end </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> start) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span></code></pre></div><h3 id="移动零" tabindex="-1">移动零 <a class="header-anchor" href="#移动零" aria-label="Permalink to &quot;移动零&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：计数器，遇到 0 就<code>counter++</code>，非 0 就<code>nums[i - couter] = nums[i] nums[i] = 0</code></li><li>思路二：双指针，一个指针正常走，另一个遇到非 0 的值加一，并<code>nums[j++] = nums[i]</code></li></ul><h3 id="比特位计数" tabindex="-1">比特位计数 <a class="header-anchor" href="#比特位计数" aria-label="Permalink to &quot;比特位计数&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：直接遍历，与 1 取并输出结果</li><li>思路二：dp，转移方程是<code>dp[i] = dp[i / 2] + (i &amp; 1)</code></li><li>思路三：dp，转移方程是<code>dp[i] = dp[i &amp; (i - 1)] + 1</code></li><li>思路四： <ul><li>奇数就等于前一个加一</li><li>偶数就等于<code>i &gt;&gt; 1</code></li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这道题除了第一种思路，都是用一些方法来减少计算，中间有很多计算结果，可以避免重复计算</p></div><h3 id="_4-的幂" tabindex="-1">4-的幂 <a class="header-anchor" href="#_4-的幂" aria-label="Permalink to &quot;4-的幂&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：直接循环除以 4</li><li>思路二：4 的 n 次方取模 3 为 1，4 的 n 次方*2 取模 3 为 2，所以通过取模可以得到结果</li><li>思路三：<code>n &amp; n - 1</code>并且<code>n &amp; 0xaaaaaaaa === 0</code></li></ul><h3 id="两个数组的交集" tabindex="-1">两个数组的交集 <a class="header-anchor" href="#两个数组的交集" aria-label="Permalink to &quot;两个数组的交集&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：暴力法+哈希表，直接<code>O(M*N)</code></li><li>思路二：先排序，再双指针比较</li></ul><h3 id="找不同" tabindex="-1">找不同 <a class="header-anchor" href="#找不同" aria-label="Permalink to &quot;找不同&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/find-the-difference/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一： 把其中一个转成哈希表</li><li>思路二：利用位运算符的异或运算，类似<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noreferrer">只出现一次的数字</a></li></ul><h3 id="二进制手表" tabindex="-1">二进制手表 <a class="header-anchor" href="#二进制手表" aria-label="Permalink to &quot;二进制手表&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/binary-watch/" target="_blank" rel="noreferrer">地址</a></p><ul><li>枚举所有时间，即 12 小时 60 分钟，然后计算出其中二进制位为 1 的数量</li><li>枚举<code>2 ** 10</code>，取出高 4 位和低 6 位的值，分别计算是否在 12 和 60 以内</li></ul><h3 id="数字转换为十六进制数" tabindex="-1">数字转换为十六进制数 <a class="header-anchor" href="#数字转换为十六进制数" aria-label="Permalink to &quot;数字转换为十六进制数&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：循环除以 16，取余数</li><li>思路二：使用位运算符</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>遇到<code>2 ** n</code>问题，首先可以考虑位运算符，提升运算效率</p></div><h3 id="排列硬币" tabindex="-1">排列硬币 <a class="header-anchor" href="#排列硬币" aria-label="Permalink to &quot;排列硬币&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/arranging-coins/" target="_blank" rel="noreferrer">地址</a></p><p>思路一：直接迭代，求前 m 项和，直到前 m 项和大于 n，就输出 n - 1 思路二：二分查找</p><h3 id="找到所有数组中消失的数字" tabindex="-1">找到所有数组中消失的数字 <a class="header-anchor" href="#找到所有数组中消失的数字" aria-label="Permalink to &quot;找到所有数组中消失的数字&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noreferrer">地址</a></p><p>两次遍历</p><ul><li>第一次需要把原数组中需要剔除的数加上 len 的倍数</li><li>第二次只需要找出数组中小于 len 的索引并-1</li></ul><h3 id="重复的子字符串" tabindex="-1">重复的子字符串 <a class="header-anchor" href="#重复的子字符串" aria-label="Permalink to &quot;重复的子字符串&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noreferrer">地址</a></p><ul><li>暴力法，直接挨个比对，i 从 <code>1 =&gt; n / 2</code>，<strong>比较难想到的是</strong>对比<code>s[j]</code>和<code>s[j - i]</code>，</li><li>将字符串<code>s</code>自加<code>s + s</code>，然后判断字符串<code>s</code>的第 1 个索引<code>s.indexOf(s, 1)</code>是否与<code>s</code>的长度相等，相等则返回 false</li><li><a href="https://zhuanlan.zhihu.com/p/83334559" target="_blank" rel="noreferrer">KMP 算法</a></li></ul><h3 id="岛屿的周长" tabindex="-1">岛屿的周长 <a class="header-anchor" href="#岛屿的周长" aria-label="Permalink to &quot;岛屿的周长&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/island-perimeter/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：直接遍历，然后推倒右侧/下侧是否为 1，是的话就-2</li><li>思路二：深度优先遍历(DFS)</li></ul><h3 id="提莫攻击" tabindex="-1">提莫攻击 <a class="header-anchor" href="#提莫攻击" aria-label="Permalink to &quot;提莫攻击&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/teemo-attacking/" target="_blank" rel="noreferrer">地址</a></p><p>关键点在于间隔时间是否大于持续时间，如果持续时间小于间隔就加上持续时间，反之则加上时间间隔，最后再加上持续时间</p><h3 id="二叉搜索树中的众数" tabindex="-1">二叉搜索树中的众数 <a class="header-anchor" href="#二叉搜索树中的众数" aria-label="Permalink to &quot;二叉搜索树中的众数&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noreferrer">地址</a></p><ul><li>思路一：直接深度优先遍历，存到 map，然后再排序，输出前几项一样大结果</li><li>思路二：中序遍历，然后记录连续的数，做一定判断</li><li>思路三： Morris 中序遍历</li></ul><p><strong>Morris 核心思路</strong></p><ul><li>如果当前节点没有左子树，则遍历这个点，然后跳转到当前节点的右子树。</li><li>如果当前节点有左子树，那么它的前驱节点一定在左子树上，我们可以在左子树上一直向右行走，找到当前点的前驱节点。 <ul><li>如果前驱节点没有右子树，就将前驱节点的 right 指针指向当前节点。这一步是为了在遍历完前驱节点后能找到前驱节点的后继，也就是当前节点。</li><li>如果前驱节点的右子树为当前节点，说明前驱节点已经被遍历过并被修改了 right 指针，这个时候我们重新将前驱的右孩子设置为空，遍历当前的点，然后跳转到当前节点的右子树。</li></ul></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 左节点不存在，直接处理当前节点，然后指针移到右节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">node.left) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">update</span><span style="color:#E1E4E8;">(node.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">    node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 左节点存在，将pre指针指向左节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  pre </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 一直向右走，找到前驱节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (pre.right </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> pre.right </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    pre </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pre.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果前驱节点没有右节点，就把让前驱的right节点指向当前节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">pre.right) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    pre.right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">    node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 恢复设置的节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    pre.right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">update</span><span style="color:#E1E4E8;">(node.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">    node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (node) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 左节点不存在，直接处理当前节点，然后指针移到右节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">node.left) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">update</span><span style="color:#24292E;">(node.val);</span></span>
<span class="line"><span style="color:#24292E;">    node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.right;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 左节点存在，将pre指针指向左节点</span></span>
<span class="line"><span style="color:#24292E;">  pre </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.left;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 一直向右走，找到前驱节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (pre.right </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> pre.right </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> node) {</span></span>
<span class="line"><span style="color:#24292E;">    pre </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pre.right;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果前驱节点没有右节点，就把让前驱的right节点指向当前节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">pre.right) {</span></span>
<span class="line"><span style="color:#24292E;">    pre.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">    node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.left;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 恢复设置的节点</span></span>
<span class="line"><span style="color:#24292E;">    pre.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">update</span><span style="color:#24292E;">(node.val);</span></span>
<span class="line"><span style="color:#24292E;">    node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.right;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>遇到二叉搜索数，记得使用中序遍历，遍历的结果是一个有序数组</p></div><h2 id="medium" tabindex="-1">medium <a class="header-anchor" href="#medium" aria-label="Permalink to &quot;medium&quot;">​</a></h2><h3 id="格雷编码" tabindex="-1">格雷编码 <a class="header-anchor" href="#格雷编码" aria-label="Permalink to &quot;格雷编码&quot;">​</a></h3><p><a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noreferrer">地址</a></p><p>思路一：加一 + 逆序 00 01 11 10 =&gt; 100 101 111 110 =&gt; 110 111 101 100 思路二：右移 + 与原数去亦或 110 =&gt; 111 =&gt; 001</p><h2 id="常考题" tabindex="-1">常考题 <a class="header-anchor" href="#常考题" aria-label="Permalink to &quot;常考题&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> subject </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;234 回文链表(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;206 反转链表(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;141 环形链表(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;148 排序链表(中等)&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// ??</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;160 相交链表(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;5 最长回文子串(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;14 最长公共前缀(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;3 无重复字符的最长子串(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;674 最长连续递增序列(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;11 盛最多水的容器(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;26 删除有序数组中的重复项(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;560 和为 K 的子数组(中等)&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// ?</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;1 两数之和(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;167 两数之和 II - 输入有序数组(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;15 三数之和(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;18 四数之和(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;55 跳跃游戏(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;45 跳跃游戏 II(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;236 二叉树的最近公共祖先(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;700 二叉搜索树中的搜索(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;450 删除二叉搜索树中的节点(中等)&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// ?</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;222 完全二叉树的节点个数(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;103 二叉树的锯齿形层序遍历(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;452 用最少数量的箭引爆气球(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;56 合并区间(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;392 判断子序列(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;34 在排序数组中查找元素的第一个和最后一个位置(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;300 最长递增子序列(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;322 零钱兑换(中等)&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// ?</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;1143 最长公共子序列(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;516 最长回文子序列(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;53 最大子数组和(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;121 买卖股票的最佳时机(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;122 买卖股票的最佳时机 II(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;309 最佳买卖股票时机含冷冻期(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;714 买卖股票的最佳时机含手续费(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;752 打开转盘锁(中等)&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// ??</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;111 二叉树的最小深度(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;155 最小栈(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;496 下一个更大元素 I(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;503 下一个更大元素 II(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;20 有效的括号(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;71 简化路径(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;695 岛屿的最大面积(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;100 相同的树(简单)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;46 全排列(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;22 括号生成(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;93 复原 IP 地址(中等)&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// ?</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;78 子集(中等)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">];</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> subject </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;234 回文链表(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;206 反转链表(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;141 环形链表(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;148 排序链表(中等)&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// ??</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;160 相交链表(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;5 最长回文子串(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;14 最长公共前缀(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;3 无重复字符的最长子串(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;674 最长连续递增序列(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;11 盛最多水的容器(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;26 删除有序数组中的重复项(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;560 和为 K 的子数组(中等)&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// ?</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;1 两数之和(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;167 两数之和 II - 输入有序数组(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;15 三数之和(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;18 四数之和(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;55 跳跃游戏(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;45 跳跃游戏 II(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;236 二叉树的最近公共祖先(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;700 二叉搜索树中的搜索(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;450 删除二叉搜索树中的节点(中等)&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// ?</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;222 完全二叉树的节点个数(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;103 二叉树的锯齿形层序遍历(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;452 用最少数量的箭引爆气球(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;56 合并区间(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;392 判断子序列(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;34 在排序数组中查找元素的第一个和最后一个位置(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;300 最长递增子序列(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;322 零钱兑换(中等)&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// ?</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;1143 最长公共子序列(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;516 最长回文子序列(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;53 最大子数组和(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;121 买卖股票的最佳时机(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;122 买卖股票的最佳时机 II(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;309 最佳买卖股票时机含冷冻期(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;714 买卖股票的最佳时机含手续费(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;752 打开转盘锁(中等)&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// ??</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;111 二叉树的最小深度(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;155 最小栈(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;496 下一个更大元素 I(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;503 下一个更大元素 II(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;20 有效的括号(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;71 简化路径(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;695 岛屿的最大面积(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;100 相同的树(简单)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;46 全排列(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;22 括号生成(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;93 复原 IP 地址(中等)&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// ?</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;78 子集(中等)&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">];</span></span></code></pre></div>`,160),e=[o];function r(t,c,E,y,i,d){return a(),n("div",null,e)}const u=s(p,[["render",r]]);export{F as __pageData,u as default};
